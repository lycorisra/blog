[{"title":"vim菜鸟教程","date":"2018-08-13T16:00:00.000Z","path":"2018/08/14/vim-basic/","text":"vim是从vi发展出来的文本编辑器，所有的Uninx Like系统都会内建vi文本编辑器，目前使用最多的是vim。基本上vi/vim共分为三种模式，分别是命令模式（Command Mode）、输入模式（Insert mode）和底线命令模式（Last line mode） 命令模式：用户启动vi/vim，便进入命令模式，此状态下的输入回被vim识别为命令，而非输入字符，输入i，便切换到输入模式；输入:，便切换到底线命令模式，以在最底下一行输入命令。命令模式只有一些最基本的命令，因此，仍要依靠底线命令模式输入更多的命令 输入模式：在命令模式下输入i即可进入输入模式，在输入模式中，可以使用如下按键：HOME/END：移动光标到行首或行尾；Page Up/Page Down：上/下翻页；Insert：切换光标为输入/替换模式，光标将变为竖线/下划线；esc：退出输入模式，切换到命令模式； 底线命令模式：在命令模式下输入:即可进入底线命令模式，该模式下可以输入单个或多个字符的命令，基本命令有:q（退出程序）、:w（保存文件）和:wq（保存并离开） vi/vim常用命令说明移动光标 向左移动一个字符：h或左箭头 向右移动一个字符：l或右箭头 向上移动一个字符：k或上箭头 向下移动一个字符：j或下箭头说明：如果想多次移动，可以使用数字+相应字符的组合按键的形式，例如：30j表示向下移动30行 屏幕之间光标移动 向下移动一页：ctrl+f，相当于Page Down，移动半屏（ctrl+d） 向上移动一页：ctrl+b，相当于Page Up，移动半屏（ctrl+u） 向右移动n个字符：n，n表示数字，space表示空格 移到屏幕最上方那一行的第一个字符：H 移到屏幕中间的那一行的第一个字符：M 移到屏幕最下方那一行的第一个字符：L 移到文案的最后一行：G 光标向下移动n行：n说明：光标向下移动n行，也可以使用nj，两者的区别是n除了向下移动n行外，光标会回到改行的第一个字符，而nj光标移动n行后保持不变 搜索与替换 向下搜索：/word，配合字母n，代表重复前一个搜索动作 向上搜索：?word配合字母n，代表重复前一个搜索动作，例如：如果刚刚执行/word，按下n后，则会【向下】继续搜索下一个名为word的字符串；如果?word，按下n后，则会【向上】继续搜索word的字符串；N与n相反，为反向重复前一个搜索动作，例如：执行/word，按下N，则【向上】继续搜索 在指定行范围内替换：:n1,n2s/word1/word2/g，n1和n2位数字，在第n1和n2行之间寻找word1字符串，并将改字符串替换为word2。 匹配项高亮显示：:set hls，取消高亮：:set nohls 忽略大小写：:set ic，取消忽略大小写：:set noic 复制、粘贴与删除 复制光标所在行：yy 复制光标所在行（包括改行）的向下n行：nyy 复制光标所在行到第一行的所有行：y1G 复制光标所在行到最后一行的所有行：yG 复制光标所在字符到该行行首的所有字符：y0 复制光标所在字符到该行行尾的所有字符：y$ 在光标所在行的下一行开始粘贴：p 在光标所在行的上一行开始粘贴：P 删除一个字符：x/X，x表示向后删除一个字符；X表示向前删除一个字符（相当于退格键） 删除多个字符：nx，n为数字，表示连续向后删除n个字符 删除光标所在行：dd 删除光标所在行（包括该行）的向下n行：ndd 删除光标所在行到第一行的所有行：d1G 删除光标所在行到最后一行的所有行：dG 删除指定范围行：n1,n2d，n1表示开始行，n2表示结束行，关于删除，在vim中，“.”表示当前行，例如：“1,.”表示第一行到当前行，d表示删除 删除光标所在字符到该行的最后一个字符：d$ 删除光标所在字符到该行第一个字符：d0 撤销与重做：u/ctrl+r，u表示撤销前一个动作，ctrl+r表示重做上一个动作，小数点.也表示重复前一个动作 重复前一个动作：小数点.，如果想重复删除、复制和粘贴等操作不断按下.即可 行合并，将光标所在行与下一行合并为一行：J 折叠与展开 折叠：zc，折叠所有嵌套：zC 展开折叠：zo，展开所有折叠嵌套：zO 常用命令 光标移到行首：0或功能键Home 光标移到行尾：$或功能键End 光标移到最后一行：G 光标移到指定的行：nG，n为数字 光标移到第一行：gg，相当于1G 显示行号：:set nu/:set number，取消行号：:set nonu/:set nonumber 全局替换：:1,$s/word1/word2/gc，其中参数c表示替换前显示提示符让用户确认是否替换，或:%s/word1/word2/gc 一般模式（命令模式）切换到输入模式 i,I：i为从当前光标所在处开始输入；I为在当前行所在的第一个非空格处开始输入 a,A：a为从当前光标所在的下一个字符串开始输入，A为从当前光标所在行最后一个字符串开始输入 o,O：o为从当前光标所在行的下一行处开始输入；O表示从当前光标所在处的上一行开始输入 ###退出vim编辑器:w：将编辑内容写入到硬盘:w!：若文件属性为【只读】时，强制写入，不过最终能不能写入，还是看该文档的权限:w [filename]：另存为一个新的文件:q：离开vim编辑器:q!：强制离开vim编辑器，此时编辑内容会丢失:wq：保存并离开:wq!：强制保存并离开 教程链接：http://www.runoob.com/linux/linux-vim.html","excerpt":"vim是从vi发展出来的文本编辑器，所有的Uninx Like系统都会内建vi文本编辑器，目前使用最多的是vim。基本上vi/vim共分为三种模式，分别是命令模式（Command Mode）、输入模式（Insert mode）和底线命令模式（Last line mode） 命令模式：用户启动vi/vim，便进入命令模式，此状态下的输入回被vim识别为命令，而非输入字符，输入i，便切换到输入模式；输入:，便切换到底线命令模式，以在最底下一行输入命令。命令模式只有一些最基本的命令，因此，仍要依靠底线命令模式输入更多的命令 输入模式：在命令模式下输入i即可进入输入模式，在输入模式中，可以使用如下按键：HOME/END：移动光标到行首或行尾；Page Up/Page Down：上/下翻页；Insert：切换光标为输入/替换模式，光标将变为竖线/下划线；esc：退出输入模式，切换到命令模式； 底线命令模式：在命令模式下输入:即可进入底线命令模式，该模式下可以输入单个或多个字符的命令，基本命令有:q（退出程序）、:w（保存文件）和:wq（保存并离开）","tags":[{"name":"vim","slug":"vim","permalink":"https://github.com/yssa1258/lycorisra/tags/vim/"}]},{"title":"webpack打包实践（1）- 基础框架","date":"2018-03-10T06:53:14.000Z","path":"2018/03/10/webpack-in-practice_01/","text":"打包策略这一阶段主要是针对design页面的资源进行打包，同时考虑到后期要对所有页面打包的扩展性，决定采用多入口文件打包策略，初步制定的打包策略如下： 抽离出所有页面公共的第三方js文件包括扩展，打包为lib.js，每个页面自己引用的第三方文件打包为vender.js 所有css文件全部打包进main.css文件中，这里没有进行css拆分处理 通过AMD模块依赖的js文件打包进design.component.js文件中，实现模块的按需加载，依赖的css文件通过ExtractTextPlugin插件自动合并到main.css中 css文件中引入的图片资源通过url-loader进行打包 针对非模块化的js文件，例如jQuery，通过expose-loader暴露出所需的全局变量$和jQuery，自定义的全局变量，例如userInfo，通过代码window.userInfo = userInfo方式，实现全局访问 所有打包完成后的输出文件最终会上传到阿里云，进行CDN处理 制定好了打包策略后，开始影响后面的整个打包过程 资源分析需要打包的资源主要包括ejs、js、css和图片等，此外，还需要梳理出这些资源的引用方式，目前资源引用方式主要有以下几种： 大部分资源通过AMD方式加载，包括ejs、css和js，其中由于Require.js不能直接处理css和html文件，所以在依赖ejs和css这两类文件时，在路径前面分别添加了“!text”和“!css”前缀，所以后面需要特殊处理 一部分文件没有实现模块化规范，比如login/main.js文件，该文件中暴露了全局变量userInfo，但是在webpack打包后，userInfo变为局部变量，导致在外部无法访问该变量了，解决方法是将需要暴露的全局变量放在window对象下面，例如window.userInfo = userInfo 一部分第三方库，这些库大部分（有没有未实现的还需要确认）实现了常有的模块规范，如果这些模块未依照模块规范依赖的方式加载，且需要暴露该模块的全局变量，此时需要使用expose-loader进行处理，这些模块配置在expose.js文件中 对于通过html标签（script、link和img等）方式引入的资源，需要手工进行梳理，然后配置到相应的入口文件中，特别是ejs通过include方式复用的公共ejs模板需要通过递归处理，目前主要是通过自己写的ejs-parse.js来完成这一步 图片资源的处理，webpack的css-loader天然支持对css文件中的图片资源的处理，但是对html中的img标签及js文件中通过字符串拼接的图片资源无法很好的处理，所以这一阶段只对css文件中的图片进行处理（说明：html-loader可以实现html标签内的图片进行处理，这在后面进行说明） webpack配置分析完资源类型和资源加载方式后，开始创建webpack打包的配置文件webpack.config.js，由于采用多入口文件打包策略，所以需要先配置入口文件，然后再根据入口文件生成多个配置项，这里添加了三个文件webpack.config.js、base.config.js和entry.js，入口文件配置如下：1234567891011121314151617181920212223242526272829303132333435module.exports = [ &#123; \"name\": \"lib\", \"entry\": &#123; \"lib\": [ \"/js/lib/jquery.js\", \"/js/lib/ejs.js\", \"/js/lib/ejs2.js\", \"/js/lib/require.js\" ] &#125; &#125;, &#123; \"name\": \"design2\", \"template\": \"views/design-v2.ejs\", \"filename\": \"../views/design-v2.ejs\", \"entry\": &#123; \"design2/js/main\": \"views/design-v2/main.js\", \"design2/js/vendor\": [ \"/js/lib/jquery-ui.min.js\", \"/js/lib/jsPDF.js\", \"/js/lib/md5.min.js\", \"/js/lib/rgbcolor.js\", \"/js/lib/StackBlur.js\", \"/js/lib/canvg.min.js\", \"/js/lib/glfx.js\", \"/js/lib/qrcode2.js\", \"/js/lib/fontfaceobserver.js\", \"/views/design-v2/left-coms/background/colorp.js\", \"/views/design-v2/header-coms/color/jscolor.js\" ] &#125; &#125; ......&#125; 说明： jquery-ui.min.js库文件必须放在jQuery插件前面，否则，打包完成后会导致jQuery相关的插件无法使用； name：为入口文件名称，对应为打包后该入口文件夹的目录名称； entry：为一个对象，配置入口文件依赖的资源列表，webpack将根据每个键对应的资源打包到进以该键名命名的文件中，由于键名称带有路径符号，所以打包输出后的文件具有对应的目录结构； template：为入口页面模板，webpack以此为模板，使用HtmlWebpackPlugin插件，打包完成后将最终的资源引用更新到模板内容，然后输出到filename指定的文件中； filename: HtmlWebpackPlugin输出文件，这里由于template和filename配置的名称一样，即每个入口页面既作为模板又作为输出文件，所以在webpack打包完成后，替换资源引用之前，必须先清除掉页面中重复的资源引用（主要为js和css），详细参考plugins.js中的自定义插件HtmlResourceWebpackPlugin base.config.js里配置了webpack基础配置项，主要包括module、resolve、resolveLoader和plugins等，其余内容通过entry.js里的每个入口配置内容进行构造，生成每一个入口文件最终的webpack配置对象。webpack.config.js是webpack打包的默认配置文件，使用webpack命令时即以该文件作为配置文件，对项目进行打包。12345678910111213const path = require('path');const entry = require('./build/entry');const baseConfig = require('./build/base.config');module.exports = (option = &#123;&#125;) =&gt; &#123; var opts = []; for (var i = 0; i &lt; entry.length; i++) &#123; var opt = baseConfig(entry[i], option); opts.push(opt); &#125; return opts;&#125; 环境配置目前我们项目中，webpack运行环境分为开发环境、测试环境和正式环境，三者之间的区别如下： 开发环境，无需代码压缩，支持sourcemap调试，不需上传CDN，需要开启本地服务 测试环境，无需代码压缩、需上传CDN，支持sourcemap调试 正式环境，代码压缩、、需上传CDN，不支持sourcemap调试 所以，运行环境不同，webpack配置项也不同，因此添加四个文件：_develop.js、_test.js、_production.js和default.js，分别用于配置开发环境、测试环境和正式环境及默认环境下webpack打包配置，另外，还添加了两个文件dev-routes.js和dev-server.js,用于开发环境下，搭建webpack本地服务器来辅助开发。 自定义插件webpack打包完成后，HtmlWebpackPlugin插件会在filename属性配置的页面中插入script和link标签，生成最终的资源引用，由于这些页面既作为模板又作为输出文件（即filename和template配置的是用一个文件），所以在webpack打包完成后，生成资源引用之前，需要删除掉已有的script和link标签，防止资源的重复引用。因此，自定义插件：HtmlResourceWebpackPlugin，具体代码参考plugins.js CDN处理非开发环境下，webpack打包完毕后，最终会将所有资源输出到public/dist目录下，该目录根据入口文件结构进行组织，然后遍历该目录下的所有文件，根据当前环境配置，上传到相应的CDN地址。相应的代码实现参考deploy.js. 开发开发环境下，运行npm run dev-server命令后，开始执行打包，并启动本地服务，端口为3005，同时该服务承载了另一个webpack服务，该服务会实时监听本地文件变化，因此当修改代码后，会自动重新打包，打包完成后刷新浏览器即可看到变化；其中，dev-routes.js用于进行路由处理，在响应每一个页面请求之前，先发起一个新的对webpack服务器同样路由的请求，该请求从内存中加载资源，然后将响应返回给前端，这样，整个过程实现了本应该从磁盘访问到内存访问的转换，避免了开发环境下频繁修改本地文件，也提升了开发效率。相关代码参考dev-routes.js。 部署所有打包相关的命令都已经配置到package.json里的scripts项里，运行npm run [script]即可执行相关命令12345678910&#123; \"scripts\": &#123; \"dev\": \"webpack --env.config default --progress --colors\", \"dev-server\": \"node ./build/dev-server.js\", \"build\": \"webpack --env.config test --progress --colors &amp;&amp; node ./build/deploy test\", \"publish\": \"webpack -p --env.config production --progress --colors &amp;&amp; node ./build/deploy production\", \"deploy\": \"node ./build/deploy\", \"parse\": \"node ./build/ejs-parse.js\" &#125;&#125; 说明如下： dev：运行本地打包，该命令不会启动webpack服务器，打包完成后资源输出到public/dist目录下 dev-server：运行本地打包，并且会启动webpack服务器，打包完成后所有资源进入内存，不会修改本地文件 build：测试环境打包命令，打包完成后会更新入口页面中的script和link资源引用，并上传打包资源到CDN测试地址 publish：正式环境打包命令，打包完成后会更新入口页面中的script和link资源引用，并上传打包资源到CDN正式地址 deploy：打包资源上传CDN命令，可以单独运行，但一般跟在打包脚本后执行 parse：解析ejs文件中的资源（js、css和图片），后面可以带参数 打包代码结构所有webpack打包相关的代码全部放在build目录下12345678910111213141516├── build│ ├── docs│ ├── _develop.js│ ├── _production.js│ ├── _test.js│ ├── base.config.js│ ├── default.js│ ├── deploy.js│ ├── dev-routes.js│ ├── dev-server.js│ ├── ejs-parse.js│ ├── entry.js│ ├── expose.js│ ├── plugins.js│ ├── utils.js└── webpack.config.js 其中，相关文件说明如下： docs：webpack打包说明文档 _develop.js：开发环境下，webpack打包配置，包含devtool和output配置项 _test.js：测试环境下，webpack打包配置，包含devtool和output配置项及阿里云oss上传配置 _production.js：正式环境下，webpack打包配置，包含devtool和output配置项及阿里云oss上传配置 base.config.js：webpack基础配置项，根据入口文件entry.js生成最终的webpack配置对象数组 default.js：默认环境配置，默认为develop deploy.js：打包后的资源上传到阿里云oss相关代码 dev-routes.js：开发环境下，webpack本地服务器路由信息配置 dev-server.js：开发环境下，webpack本地服务器实现代码 ejs-parse.js：ejs文件解析，主要通过正则表达式匹配ejs文件中的script、link和img及include等标签，解析相关的js、css和图片资源，形成入口文件数据结构，并提供img标签图片资源替换和图片打包等方法 entry.js：入口文件数组，每个入口文件包含name、template、filename和entry等信息 expose.js：设置需要暴露全局变量的第三方库文件 plugins.js：webpack自定义插件，目前包含两个插件：HtmlResourceWebpackPlugin和AssetsParseWebpackPlugin，分别用于资源引用替换和资源输入输出解析 utils.js：常用工具函数，目前主要包含Node端文件处理相关的方法 注意事项需要注意的是，以下情况会导致打包失败： entry.js配置项中，entry属性数组中不能有重复的资源，或者template配置项前面不能以“html-loader”开头； html-loader的attrs属性配置了“link:href”，所以如果需要处理link标签中图片，需单独处理； 在定义AMD模块时，之前依赖的ejs路径带有“!text”前缀，html-loader在无法解析该路径，所以需要去掉“!text”","excerpt":"打包策略这一阶段主要是针对design页面的资源进行打包，同时考虑到后期要对所有页面打包的扩展性，决定采用多入口文件打包策略，初步制定的打包策略如下： 抽离出所有页面公共的第三方js文件包括扩展，打包为lib.js，每个页面自己引用的第三方文件打包为vender.js 所有css文件全部打包进main.css文件中，这里没有进行css拆分处理 通过AMD模块依赖的js文件打包进design.component.js文件中，实现模块的按需加载，依赖的css文件通过ExtractTextPlugin插件自动合并到main.css中 css文件中引入的图片资源通过url-loader进行打包 针对非模块化的js文件，例如jQuery，通过expose-loader暴露出所需的全局变量$和jQuery，自定义的全局变量，例如userInfo，通过代码window.userInfo = userInfo方式，实现全局访问 所有打包完成后的输出文件最终会上传到阿里云，进行CDN处理 制定好了打包策略后，开始影响后面的整个打包过程","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/yssa1258/lycorisra/tags/webpack/"}]},{"title":"webpack打包实践（2）- 处理ejs文件","date":"2018-03-10T06:46:04.000Z","path":"2018/03/10/webpack-in-practice_02/","text":"第一阶段已经完成了webpack打包代码基础框架，并在此基础上完成了design页面的打包工作，但是打包工作仍然不够彻底，还有很大工作需要完成，这一期主要完成以下两个任务： design页面有部分js和css文件没有打包，这部分文件主要是include方式引用的公共模板加载的资源 其他剩余的页面没有打包，这些页面引入的资源数量远没有design那么多，但资源比较分散，不好抽离出公共部分，所以进行统一处理 以上两条各自的难点如下： ejs模板是在后端动态渲染的，webpack静态分析模块加载和依赖的时候无法解析入口页面中include进来的ejs模板文件包含的资源，所以需要借助Node遍历这些文件，并完成资源解析工作 现有的loader不能很好的处理页面中的script和link标签，同时，由于页面繁多，同样需要借助Node遍历views目录下所有页面，生成每个页面的入口信息 简而言之，这一阶段的工作主要就是如何生成webpack打包的入口列表 查找入口文件前期入口文件仅仅只包含了名为lib和design2的两个入口文件，这一期需要将所有页面包含进来。由于页面繁多，并且每个页面包含的资源不一样，所以这里通过Node遍历views目录下的所有页面文件，来查找入口文件及其资源引用，所有相关代码参考文件ejs-parse.js，实现思路如下： 遍历views目录 12345678910111213141516171819202122function lsdir(dir, entry, callback) &#123; return utils.stat(dir).then(stats =&gt; &#123; if (stats.isDirectory()) &#123; return utils.readdir(dir).then(files =&gt; &#123; return Promise.all(files.map(file =&gt; &#123; return lsdir(path.resolve(dir, file), entry, callback) &#125;)) &#125;).then(items =&gt; &#123; items = items.filter(item =&gt; &#123; return item != null; &#125;) entry = entry.concat(...items); return entry; &#125;) &#125; else &#123; var item = null, extend = dir.substr(dir.lastIndexOf('.')); item = extend === '.ejs' ? readEjsFile(dir, callback) : item; return item; &#125; &#125;)&#125; 对遍历到的每一个ejs文件，读取内容，然后解析出其中的script和link标签，由于解析js和css，所以callback传递的是parseEjs方法，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 解析页面文件 * @param &#123;*&#125; file */function readEjsFile(file, callback) &#123; return utils.readfile(file).then(content =&gt; &#123; var entry = []; typeof callback === 'function' &amp;&amp; (entry = callback(file, content)); return Promise.resolve(entry); &#125;).catch(error =&gt; &#123; throw error; &#125;);&#125;/** * 解析ejs文件 * @param &#123;*&#125; file * @param &#123;*&#125; content */function parseEjs(file, content) &#123; var array = [], temp = []; // 优先解析include标签，避免因为资源引用加载的先后顺序导致的问题（例如，reset.min.css需要最先记载，否则在QQ浏览器上出现样式的问题） temp = parseIncludes(file, content); array = array.concat(temp); temp = parseLinks(content); array = array.concat(temp); temp = parseScripts(content); array = array.concat(temp); // 如果入口列表为空，则直接返回，防止webpack在打包时报错 if (array.length === 0) &#123; return null; &#125; // 过滤掉重复的资源引用，否则webpack打包会失败 array = array.filter(function (item, index, self) &#123; return self.indexOf(item) === index; &#125;); var filename = file.replace(directory, '').replace(/\\\\/gi, '/'), name = filename.substr(0, filename.lastIndexOf('.')), template = 'views/' + filename; var item = &#123; name: name, template: 'html-loader!' + template, filename: '../' + template, // filename: path.resolve(__dirname, '../public/dist/' + name + '/views/main.ejs'), entry: &#123; [name + '/js/main']: array &#125; &#125; return item;&#125; 其中，parseEjs解析资源的时候，对script、link，include和img等标签都做了类似的处理，即通过正则表达式，匹配出这些标签，然后再正则匹配得到资源的url地址，相关代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/** * 解析link标签 * @param &#123;*&#125; content */function parseLinks(content) &#123; var array = []; var links = content.match(/&lt;link\\s+.*\\s?(href=\\\"?.*.css).*&gt;/ig); if (links) &#123; for (var i = 0, link; link = links[i]; i++) &#123; var _links = link.match(/href=\\\"?.*.css/gi); var link = _links ? _links[0] : ''; link = link.split('=')[1].replace(/\\\"/gi, ''); // 过滤掉第三方在线引用资源和重复的资源，资源重复会导致webpack打包失败 if (!ignore(link) &amp;&amp; array.indexOf(link) === -1) &#123; array.push(link); &#125; &#125; &#125; return array;&#125;/** * 解析script标签 * @param &#123;*&#125; content */function parseScripts(content) &#123; var array = []; var scripts = content.match(/&lt;script\\s+.*\\s?(src=\\\"?.*.js).*&gt;&lt;\\/script&gt;/ig); if (scripts) &#123; for (var i = 0, script; script = scripts[i]; i++) &#123; var _scripts = script.match(/src=\\\"?.*.js/gi); var script = _scripts ? _scripts[0] : ''; script = script.split('=')[1].replace(/\\\"/gi, ''); // 过滤掉第三方在线引用资源和重复的资源，资源重复会导致webpack打包失败 if (!ignore(script) &amp;&amp; array.indexOf(script) === -1) &#123; array.push(script); &#125; &#125; &#125; return array;&#125;/** * 解析include标签 * @param &#123;*&#125; file * @param &#123;*&#125; content */function parseIncludes(file, content) &#123; var array = []; var includes = content.match(/&lt;\\%-\\s?include(\\('.*',?.*\\))\\s?%&gt;/ig); if (includes) &#123; for (var i = 0, include; include = includes[i]; i++) &#123; include = include.split(',')[0]; // 去掉include方法后面的参数 var src = include.match(/('.*')/gi); src = src ? src[0] : ''; src = src.replace(/'/gi, ''); // 去掉末尾的.ejs后缀 if (src.substr(src.length - 4) === '.ejs') &#123; src = src.substr(0, src.length - 4); &#125; var fullfile = path.resolve(file, '../' + src + '.ejs'); var items = readIncludes(fullfile); array = array.concat(items); &#125; &#125; return array;&#125;/** * 解析img标签内图片地址 * @param &#123;*&#125; file * @param &#123;*&#125; content */function parseImgs(file, content) &#123; var item = null, imgs = [], imgTags = [], reg = /&lt;img\\s+.*\\s?src=([\\\"\\'\\/](?!(http:|https:|\\&lt;|\\&gt;|data:image\\/))\\/?.*(.jpg|.jpeg|.png|.gif|.svg|.webp)[\\\"\\']?)([^\\&lt;\\&gt;]*)\\s?&gt;/gi; imgTags = content.match(reg) || []; imgTags.forEach((tag, index) =&gt; &#123; var text = tag.match(/src=([\\\"\\'\\/].*(.jpg|.jpeg|.png|.gif|.svg|.webp)[\\\"\\']?)/gi); if (text) &#123; var src = text[0].replace('src=', '').replace(/(\\\"|\\')/gi, ''); imgs.push(src); &#125; &#125;); if (imgs.length &gt; 0) &#123; item = &#123; source: file, imgs: imgs &#125; &#125; return item;&#125;/** * 解析通过include方式引用的ejs文件 * @param &#123;*&#125; file */function readIncludes(file) &#123; var content = fs.readFileSync(file, 'utf8'); var array = [], temp = []; temp = parseLinks(content); array = array.concat(temp); temp = parseScripts(content); array = array.concat(temp); // header/main.ejs嵌套引用了loginState.ejs，所以，这里需要手动添加loginState相关的资源引用 if (file.indexOf('\\\\header\\\\') &gt; -1) &#123; array = array.concat(['/icoms/loginState/main.js', '/icoms/loginState/main.css']); &#125; return array;&#125; 处理include时，需要根据include引入的路径，读取引入的文件，然后再解析其中的js和css，这个过程应该是一个递归过程，但目前还没有实现，从简处理了。 输出入口文件json以下代码遍历views目录，并将遍历结果写入到build/entry.json文件中，然后再手动将entry.json内容拷贝到entry.js文件。至此，已经完成所有页面的入口配置，接下来就可以运行打包工作了。1234567891011121314151617181920212223242526/** * 遍历指定目录的ejs文件，从中解析出js和css * @param &#123;*&#125; directory * @param &#123;*&#125; persist */function lsJsAndCss(directory, persist = false) &#123; return lsdir(directory, [], parseEjs).then((entry) =&gt; &#123; // 手动添加入口配置信息中的第一项 // entry = [items[0]].concat(entry); if (persist) &#123; var file = path.resolve(__dirname, '../build/entry.json'); fs.writeFile(file, JSON.stringify(entry), (error) =&gt; &#123; if (error) &#123; throw error &#125; return Promise.resolve(file); &#125;); &#125; return Promise.resolve(entry); &#125;);&#125;var directory = path.join(__dirname, '../views/');lsJsAndCss(directory, true).then(data =&gt; &#123; console.log('解析link和script完成');&#125;); 处理Node命令参数ejs-parse.js模块除了导出常用的几个方法外，还接受Node命令行参数，以此来处理相应的操作，使用方式如：./build/ejs-parse.js style-script```123456789101112131415161718192021222324252627``` javascriptvar args = process.argv.splice(2) || [];var type = args[0] || &apos;&apos;;if (type == &apos;style-script&apos;) &#123; var directory = path.join(__dirname, &apos;../views/&apos;); lsJsAndCss(directory).then(data =&gt; &#123; console.log(&apos;解析link和script完成&apos;); &#125;);&#125;else if (type == &apos;image&apos;) &#123; var directory = path.join(__dirname, &apos;../views/&apos;); lsImgages(directory).then(data =&gt; &#123; console.log(&apos;解析img完成&apos;); &#125;);&#125;else if (type == &apos;all&apos;) &#123; var directory = path.join(__dirname, &apos;../views/&apos;); lsJsAndCss(directory).then(data =&gt; &#123; console.log(&apos;解析link和script完成&apos;); &#125;); var imgPath = path.join(__dirname, &apos;../public/&apos;); lsImgages(imgPath).then(data =&gt; &#123; console.log(&apos;解析img完成&apos;); &#125;)&#125; 说明 为避免重复打包，解析资源的时候，jquery.js, jquery.ie8.js, ejs.js, ejs2.js, require.js等文件会被添加到忽略列表中，不进行处理 如果入口文件的资源列表存在重复的项或者资源列表为空，会导致打包失败，代码中已经进行了相应的判断处理 如果一个页面的资源列表为空，则这个页面将不会进入打包流程，例如：api/loginComplete.ejs页面","excerpt":"第一阶段已经完成了webpack打包代码基础框架，并在此基础上完成了design页面的打包工作，但是打包工作仍然不够彻底，还有很大工作需要完成，这一期主要完成以下两个任务： design页面有部分js和css文件没有打包，这部分文件主要是include方式引用的公共模板加载的资源 其他剩余的页面没有打包，这些页面引入的资源数量远没有design那么多，但资源比较分散，不好抽离出公共部分，所以进行统一处理 以上两条各自的难点如下： ejs模板是在后端动态渲染的，webpack静态分析模块加载和依赖的时候无法解析入口页面中include进来的ejs模板文件包含的资源，所以需要借助Node遍历这些文件，并完成资源解析工作 现有的loader不能很好的处理页面中的script和link标签，同时，由于页面繁多，同样需要借助Node遍历views目录下所有页面，生成每个页面的入口信息 简而言之，这一阶段的工作主要就是如何生成webpack打包的入口列表","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/yssa1258/lycorisra/tags/webpack/"}]},{"title":"webpack打包实践（3）- 图片处理","date":"2018-03-10T06:36:44.000Z","path":"2018/03/10/webpack-in-practice_03/","text":"前两阶段，已经完成了所有页面的整体打包工作，但是仍然有部分图片未能打包进来，这部分图片主要是html页面（其中包括入口页面和公共模板文件，即icoms中的.ejs文件）中引入的图片资源和js文件中引入的图片，这部分图片由于没有加入webpack打包依赖列表，所以webpack无法进行打包处理，所以，需要手动将这些图片加入的打包依赖列表中，并且打包完成后，要能够更新图片资源引用地址 入口页面中的图片资源打包这部分图片资源的打包相对比较简单，使用html-loader加载器就能够处理html页面中img标签引用的图片，并且打包完成后，能够更新图片src地址，所以这部分图片的打包工作比较省事。html-loader配置如下：123456789101112&#123; test: /\\.ejs$/, use: [&#123; loader: 'html-loader', options: &#123; root: path.resolve(__dirname, '../public'), // 去掉“'link:href'”设置，否则会出现错误：Module build failed: Error: \"extract-text-webpack-plugin\" loader is used without the corresponding plugin attrs: ['img:src'] &#125; &#125; ]&#125; 注意：对于root配置项，如果未设置，则对于以“/”开头的url，html-loader默认行为是不进行转换；如果设置了root参数，则在打包之前，该参数值会被添加到url之前，然后进行打包，所以，这里将root设置为public目录，表示从该目录下解析图片资源；另外，attrs属性设置为“img:src”，表示只对img标签中的src引用的图片进行打包处理，如果需要对ling标签中的图片资源打包，需要另外处理 公共模板中的图片资源打包公共模板指的是入口页面中，通过include方式引用的html模板，这些模板文件放在public/icoms目录下，由于这些文件页面访问的时候，是在Node端动态编译的，所以webpack无法静态分析其中的模块引用，也包括图片资源。在第一阶段打包的时候，通过自己编写的ejs-parse.js已经实现了这部分文件的js和css资源打包，所以，现在扩展其中的方法，实现图片资源的打包，主要包含html内图片资源的解析，主要方法如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 解析img标签内图片地址 * @param &#123;*&#125; file * @param &#123;*&#125; content */function parseImgs(file, content) &#123; var item = null, imgs = [], imgTags = [], reg = /&lt;img\\s+.*\\s?src=([\\\"\\'\\/](?!(http:|https:|\\&lt;|\\&gt;|data:image\\/))\\/?.*(.jpg|.jpeg|.png|.gif|.svg|.webp)[\\\"\\']?)([^\\&lt;\\&gt;]*)\\s?&gt;/gi; imgTags = content.match(reg) || []; imgTags.forEach((tag, index) =&gt; &#123; var text = tag.match(/src=([\\\"\\'\\/].*(.jpg|.jpeg|.png|.gif|.svg|.webp)[\\\"\\']?)/gi); if (text) &#123; var src = text[0].replace('src=', '').replace(/(\\\"|\\')/gi, ''); imgs.push(src); &#125; &#125;); if (imgs.length &gt; 0) &#123; item = &#123; source: file, imgs: imgs &#125; &#125; return item;&#125;/** * 遍历指定目录的ejs文件，从中解析出图片资源 * @param &#123;*&#125; directory * @param &#123;*&#125; persist */function lsImgages(directory, persist = false) &#123; return lsdir(directory, [], parseImgs).then((data) =&gt; &#123; var images = [], source = []; for (var i = 0, item; item = data[i]; i++) &#123; images = images.concat(item.imgs); source.push(item.source) &#125; // 过滤掉重复的图片资源地址 images = images.filter(function (item, index, self) &#123; return self.indexOf(item) === index; &#125;); if (persist) &#123; var file = path.resolve(__dirname, '../build/images.js'); var array = images.map(function (item) &#123; return '\"' + item + '\"' + ':' + 'require(' + '\"' + item + '\"' + ')'; &#125;); fs.writeFile(file, array.join(','), (error) =&gt; &#123; if (error) &#123; throw error &#125; return Promise.resolve(file); &#125;); &#125; return Promise.resolve(&#123; images, source &#125;); &#125;);&#125; 然后，调用lsImgages方法，最终返回一个如下结构的对象：12345678910111213141516171819202122232425&#123; images: [ '/icoms/footer/images/qq-code.png', '/icoms/footer/images/wei-code.png', '/icoms/header/images/logo-white.png', '/icoms/footer/images/qq-code1.png', '/icoms/footer/images/qqicon.png', '/icoms/footer/images/wei-code1.png', '/icoms/footer/images/wechaticon.png', '/images/icon-msg.png', '/images/close-2.png', '/images/vip_icon.png', '/icoms/login/images/qq.png', '/icoms/login/images/wb.png', '/icoms/login/images/wx.png', '/icoms/outBanner/images/banner-out.jpg', '/icoms/outBanner/images/close-2.png' ], source: [ 'public/icoms/footer/main.ejs', 'public/icoms/header/main.ejs', 'public/icoms/login/main.ejs', 'public/icoms/outBanner/main.ejs', ] &#125; 其中，images是需要打包的图片，source是这些图片所在页面分布，打包完成后，需要更新这些页面的img路径，为方便后面Node端处理，source里页面路径应该为绝对路径。然后根据这个结构来构造webpack配置对象完成下一步的打包。打包完成后，剩下最后一步，就是替换source数组中模板文件的img标签的src地址，所以，自定义了一个webpack插件AssetsParseWebpackPlugin，在webpack构建流程中，挂载webpack事件钩子函数，得到静态资源（这里是图片）打包前的路径名称和打包后输出的路径名称，并根据配置项来决定是否更新页面资源的url地址。插件代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 自定义插件二：webpack打包过程中，绑定optimize-tree“事件”函数，解析webpack完成后输出的资源列表，并挂载到node的全局对象上，供后续使用 * 注意：不能绑定optimize-tree“事件”，否则打包过程中出现阻塞的问题，不知为何，所以改为绑定“after-optimize-modules事件” * @param &#123;*&#125; option */function AssetsParseWebpackPlugin(option = &#123;&#125;) &#123; this.publicPath = option.publicPath || ''; this.source = option.source; this.persist = option.persist;&#125;/** * 实现apply接口 * @param &#123;*&#125; compiler */AssetsParseWebpackPlugin.prototype.apply = function (compiler) &#123; var publicPath = this.publicPath, sourceFiles = this.source, persist = this.persist; compiler.plugin('compilation', function (compilation) &#123; compilation.plugin('after-optimize-modules', function (modules) &#123; var result = []; modules.forEach((module, index) =&gt; &#123; var source = module.resource || ''; var target = (module.assets &amp;&amp; Object.keys(module.assets)[0]) || ''; if (target) &#123; source = source.replace(path.resolve(__dirname, '../public'), '').replace(/\\\\/gi, '/'); target = publicPath + target; result.push(&#123; source, target &#125;); &#125; &#125;); if (persist) &#123; for (let i = 0, file; file = sourceFiles[i]; i++) &#123; fs.readFile(file, 'utf8', (error, content) =&gt; &#123; if (error) &#123; throw error; &#125; content = updateImgSrc(result, content); // 写入文件（覆盖） fs.writeFile(file, content, (error) =&gt; &#123; if (error) &#123; throw error &#125; &#125;); &#125;); &#125; &#125; // 这里将result对象暴露到global全局对象上，是为了在开发环境中，Node端路由处理时，热更新资源地址 global.webpack_bundles = result; &#125;); &#125;);&#125;; 说明：由于开发环境中，将打包之后的文件更改全部写入内存中，避免了直接修改本地磁盘文件，所以，在响应请求前，进行热替换，相关代码见dev-routes.js第44行123var body = ejs.compile(html, &#123; filename: fullname &#125;)(params);body = updateImgSrc(imgs, body); // 更新图片urlres.status(200).send(body) 至此，完成了公共模板中的图片资源打包工作 js文件中的图片资源打包js中的图片资源引用方式主要为动态插入带有img标签和background-image样式的html代码，这部分引入的图片资源由于没有加入打包依赖，同样不能被webpack打包处理。由于这部分图片分散比较散乱，且使用规则不一，所以需要手动更改代码。目前处理的方案是，定义一个图片结构模块images.js，包含所有需要加载的图片，提供给js模块使用，使用之前先通过require方法引入images模块，然后通过对象访问的方式就能得到具体的图片了以下是icoms/collect/main.js为例，修改之前的代码如下12345678910111213141516//弹出提示层poptips:function (type,callback) &#123; var me=this; clearTimeout(me.collect); var htmls; if (type == -1) &#123; htmls = '&lt;div class=\"pop_tips tips_fail\"&gt;&lt;img src=\"/images/i_false.png\" alt=\"\"&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;抱歉，该模板暂时被禁用！&lt;/span&gt;&lt;/div&gt;'; &#125; else if (type == 0) &#123; htmls = '&lt;div class=\"pop_tips tips_fail\"&gt;&lt;img src=\"/images/i_false.png\" alt=\"\"&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;收藏失败，请先登录&lt;/span&gt;&lt;/div&gt;'; &#125; else if (type == 1) &#123; htmls = '&lt;div class=\"pop_tips tips_success\"&gt;&lt;img src=\"/images/i_true.png\" alt=\"\"&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;收藏成功&lt;/span&gt;&lt;/div&gt;'; &#125; ......&#125; 代码修改后如下：1234567891011121314151617var image = require('js/images.js');//弹出提示层poptips:function (type,callback) &#123; var me=this; clearTimeout(me.collect); var htmls; if (type == -1) &#123; htmls = '&lt;div class=\"pop_tips tips_fail\"&gt;&lt;img src=\"'+ image.i_fail +'\" alt=\"\"&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;抱歉，该模板暂时被禁用！&lt;/span&gt;&lt;/div&gt;'; &#125; else if (type == 0) &#123; htmls = '&lt;div class=\"pop_tips tips_fail\"&gt;&lt;img src=\"'+ image.i_fail +'\" alt=\"\"&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;收藏失败，请先登录&lt;/span&gt;&lt;/div&gt;'; &#125; else if (type == 1) &#123; htmls = '&lt;div class=\"pop_tips tips_success\"&gt;&lt;img src=\"'+ image.i_true +'\" alt=\"\"&gt;&lt;span&gt;&amp;nbsp;&amp;nbsp;收藏成功&lt;/span&gt;&lt;/div&gt;'; &#125; ......&#125; 说明：images模块采用了CommonJS规范，在定义AMD模块时，可以直接引入作为其依赖模块来使用，不需要单独通过require方法引入，例如：1define(['js/images.js'], function (image) &#123; console.log(image) &#125;) webpack配置对象导出Promisewebpack配置类型除了支持单个配置对象外、还支持函数，此函数接受environment作为参数，当运行webpack时，可以通过--env指定构建环境，例如：--env.config test。同时，该函数支持Promise，允许异步处理直到返回配置对象，webpack.config.js代码如下：12345678910111213141516171819202122232425262728const path = require('path');const entry = require('./build/entry');var &#123; lsImgages &#125; = require('./build/ejs-parse');const baseConfig = require('./build/base.config');console.log('开始打包...');module.exports = (option = &#123;&#125;) =&gt; &#123; console.log('打包进行中...'); var configName = option.config || 'develop'; var directory = path.join(__dirname, './public/icoms'); return lsImgages(directory).then((&#123; images, source &#125;) =&gt; &#123; var opts = [], imgsConfig = baseConfig(&#123; name: \"images\", entry: &#123; images: images &#125;, source: source, persist: configName === 'develop' ? false : true &#125;, option); opts.push(imgsConfig); for (var i = 0; i &lt; entry.length; i++) &#123; var opt = baseConfig(entry[i], option); opts.push(opt); &#125; return Promise.resolve(opts); &#125;);&#125; 至此，所有图片已经完成打包处理，图片输出目录为dist/images，图片命名方式为：[hash].[name].[ext]","excerpt":"前两阶段，已经完成了所有页面的整体打包工作，但是仍然有部分图片未能打包进来，这部分图片主要是html页面（其中包括入口页面和公共模板文件，即icoms中的.ejs文件）中引入的图片资源和js文件中引入的图片，这部分图片由于没有加入webpack打包依赖列表，所以webpack无法进行打包处理，所以，需要手动将这些图片加入的打包依赖列表中，并且打包完成后，要能够更新图片资源引用地址","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/yssa1258/lycorisra/tags/webpack/"}]},{"title":"webpack打包实践（4）- 未完待续","date":"2018-03-10T06:28:44.000Z","path":"2018/03/10/webpack-in-practice_04/","text":"遗留问题经过前面三个阶段的工作，整个项目的前端资源打包任务已经完成预期要求，但是目前仍然存在一个很大的问题，那就是打包效率的问题。在本地开发环境下，由于每次代码更改后是增量打包，所以打包效率较快，但是，在发布到测试环境和正式环境后，进行的是全量打包。所以，不管每次代码更改量的多少，每次运行一次完整打包，从打包到上传CDN整个过程大概总共需要5分钟左右时间，在这期间，网站无法正常访问，页面样式发生错乱，带来很不好的体验； 除此之外，还有一个隐藏的问题，那就是打包配置的时候，views目录下的入口页面即作为模板又作为输出文件，每次打包完成后，webpack会修改入口页面代码（更新资源引用）。之前出现入口页面代码出错，然后导致下一次打包失败的情况。 解决方案以上两种情况，最佳的解决方案是将项目访问和项目打包分开进行，同时实现一个与本地开发环境类似的预编译机制，保证每次发布后，都是增量打包，项目打包完成后js、css和图片资源上传到CDN服务器，views目录下的入口页面上传到应用服务器，替换相应的文件，这样有效提升了打包效率，同时避免了网站短时间内无法访问的问题，也减少了打包失败的几率； 第二个解决方案就是从webpack着手，需要修改入口配置，将每个页面中公共的模块抽离出来，例如，登陆、支付、头部和尾部等模块单独打包，然后每个页面分别引用。然后，每次运行打包后，手动指定需要打包的页面，例如：npm run build --entry=home,index，然后代码里通过process.argv.splice(2)来接收参数，根据该参数对指定的入口页面进行打包。这个解决方案需要均衡打包粒度和打包效率置点的平衡点，因为有些页面依赖的资源比较少，如果打包粒度过细，打包之后和打包之前区别不大。","excerpt":"遗留问题经过前面三个阶段的工作，整个项目的前端资源打包任务已经完成预期要求，但是目前仍然存在一个很大的问题，那就是打包效率的问题。在本地开发环境下，由于每次代码更改后是增量打包，所以打包效率较快，但是，在发布到测试环境和正式环境后，进行的是全量打包。所以，不管每次代码更改量的多少，每次运行一次完整打包，从打包到上传CDN整个过程大概总共需要5分钟左右时间，在这期间，网站无法正常访问，页面样式发生错乱，带来很不好的体验； 除此之外，还有一个隐藏的问题，那就是打包配置的时候，views目录下的入口页面即作为模板又作为输出文件，每次打包完成后，webpack会修改入口页面代码（更新资源引用）。之前出现入口页面代码出错，然后导致下一次打包失败的情况。","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/yssa1258/lycorisra/tags/webpack/"}]},{"title":"react native开发环境搭建","date":"2017-10-14T16:00:00.000Z","path":"2017/10/15/hello-react-native/","text":"开发环境搭建软件安装需要安装Java JDK、Android Studio、Python 2和react-native-cli及yarn工具包 Java JDK： Android Studio： Python 2环境变量设置安装完成后手动设置相应的环境变量，如下 用户环境变量PATH末尾追加如下： 1PATH：C:\\Users\\xxx\\AppData\\Local\\Android\\sdk\\tools;C:\\Users\\xxx\\AppData\\Local\\Android\\sdk\\platform-tools 系统环境变量新增ANDROID_HOME： 1ANDROID_HOME：C:\\Users\\xxx\\AppData\\Local\\Android\\sdk 系统环境变量新增CLASSPATH： 1CLASSPATH：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 系统环境变量新增JAVA_HOME： 1JAVA_HOME：D:\\software\\java\\jdk1.8.0_131 用户环境变量PATH末尾追加如下： 1Path：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin 真机调试手机打开开发者调试，并通过数据线连接到电脑（是否需要安装手机助手，例如小米手机助手，还未确认），然后，在项目根目录下打开命令行窗口，运行react-native run-android命令，首次运行该命令耗费的时间比较长，如果一切顺利，在手机上就能看到效果。注意： react-native默认使用8081端口，如果该端口被占用，需要手动更改端口，更改方法：左右摇晃手机，打开Dev Tool界面，找到，手动输入电脑上的IP地址和端口，然后重新加载 react-native start 命令后面跟 “–port 端口号”可以手动更改端口，例如： 1react-native start --port 8083 运行react-native run-android命令前，请先运行adb devices命令确保已经连接手机，并且，确保通过react-native start命令已经开启了服务端 Node.js环境下Vue项目开发 本文主要介绍在Node.js环境下，如何进行Vue项目（移动app）开发，包括开发环境的搭建、新建Vue项目、运行项目、Webpack打包、访问移动设备和真机调试及打包发布为app等内容，尽量在每一步过程中详细、清晰明了，让人可以快速上手。 开发环境搭建 相较于传统的Web开发，Node.js环境下开发方式最大的区别在于运行环境、模块加载和开发工具等方面，所以，首先熟悉下基于Node.js开发所需的开发环境，包括JavaScript运行环境、打包工具和IDE等，以Windows系统为例，下面是Node.js开发所需的工具： Node.js：Node.js诞生与2009年3月，官网介绍如下： Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 NPM：NPM的全称是Node Package Manager，是一个NodeJS包管理和分发工具。在Node.js实际开发过程中，会使用到大量的模块，使用NPM可以帮助我们安装和管理这些模块包。 Webpack：Webpack是一个模块加载器兼打包工具，它能把各种资源，JS（含JSX）、CSS（含less/sass）、图片和文本等作为模块来使用和处理。文档地址：http://webpack.github.io/docs/ VS Code：全称Visual Studio Code，是微软在Build 2015大会上推出来的开源且跨平台的现代轻量级代码编辑器，是一款主要用于进行前端开发的IDE，支持几乎所有主流的开发语言的语法高亮、代码智能提示、Git、终端和代码调试及VS常用特性。由于是微软推出的，所以在界面和使用习惯上延续了Visual Studio的风格，对于熟练使用Visual Studio的开发者可以更容易使用。其他比较主流的类似IDE还有Sublime Text和Atom，点击相应链接可以详细了解。 HBuilder：Hbuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。其本身主体是由Java编写，基于Eclipse，所以兼容Eclipse的插件。这里我们主要使用它来进行app的调试和发布打包。 vue-cli：基于Vue.js的命令行工具，官方发布 vue.js 项目脚手架，使用 它可以快速创建、运行和发布Vue项目。 Git：是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理 安装Node.js 首先，下载好所需的安装包后，先安装Node.js，安装完成后需要注意1、设置Node.js的环境变量；2、设置Node.js全局模块安装路径。由于新版的Node.js安装完成后，已经自带NPM功能，所以，NPM不需要重新安装，在系统命令行工具中输入npm -v可以查看npm的当前版本来判断是否成功安装 安装Webpack和vue-cli 前面设置好Node.js模块全局路径后，打开cmd窗口（Win+R，输入cmd），输入“npm install webpack -g”，-g表示安装到全局的目录，这样以后在任何目录下都可以使用webpack命令。然后回车，即开始下载Webpack，下载完成后，输入“webpack -v”，查看安装的webpack的版本，判断是否成功。同样，再安装vue-cli，安装完后用“vue -V”查看当前vue-cli版本判断是否安装成功。 注意： - 1、如果遇到网络问题，出现安装缓慢或出错的情况，可以参考： 解决国内NPM安装依赖速度慢问题，或安装“cnpm”，然后使用cnpm进行安装其他模块； - 2、可以一次安装多个模块，例如：“npm install webpack vue-cli -g”模块之间使用空格隔开。 安装VS Code 安装完成后，可以进行一些个性化设置，例如， - 更改主题：打开“文件 - &gt;首选项 -＞颜色主题”，然后选择一套自己喜欢的主题 - 设置语法识别：","excerpt":"开发环境搭建软件安装需要安装Java JDK、Android Studio、Python 2和react-native-cli及yarn工具包 Java JDK： Android Studio： Python 2环境变量设置安装完成后手动设置相应的环境变量，如下","tags":[]},{"title":"基于Vue.js进行项目开发的环境搭建","date":"2017-10-14T16:00:00.000Z","path":"2017/10/15/node-develop-guid/","text":"Node.js环境下Vue项目开发 本文主要介绍在Node.js环境下，如何进行Vue项目（移动app）开发，包括开发环境的搭建、新建Vue项目、运行项目、Webpack打包、访问移动设备和真机调试及打包发布为app等内容，尽量在每一步过程中详细、清晰明了，让人可以快速上手。 1. 开发环境搭建 相较于传统的Web开发，Node.js环境下开发方式最大的区别在于运行环境、模块加载和开发工具等方面，所以，首先熟悉下基于Node.js开发所需的开发环境，包括JavaScript运行环境、打包工具和IDE等，以Windows系统为例，下面是Node.js开发所需的工具： Node.js：Node.js诞生于2009年3月，官网介绍如下： Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 NPM：NPM的全称是Node Package Manager，是一个NodeJS包管理和分发工具。在Node.js实际开发过程中，会使用到大量的模块，使用NPM可以帮助我们安装和管理这些模块包。 Webpack：Webpack是一个模块加载器兼打包工具，它能把各种资源，JS（含JSX）、CSS（含less/sass）、图片和文本等作为模块来使用和处理。文档地址：http://webpack.github.io/docs/ VS Code：全称Visual Studio Code，是微软在Build 2015大会上推出来的开源且跨平台的现代轻量级代码编辑器，是一款主要用于进行前端开发的IDE，支持几乎所有主流的开发语言的语法高亮、代码智能提示、Git、终端和代码调试及VS常用特性。由于是微软推出的，所以在界面和使用习惯上延续了Visual Studio的风格，对于熟练使用Visual Studio的开发者可以更容易使用。其他比较主流的类似IDE还有Sublime Text和Atom，点击相应链接可以详细了解。 HBuilder：Hbuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。其本身主体是由Java编写，基于Eclipse，所以兼容Eclipse的插件。这里我们主要使用它来进行app的调试和发布打包。 vue-cli：基于Vue.js的命令行工具，官方发布 vue.js 项目脚手架，使用 它可以快速创建、运行和发布Vue项目。 Git：是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理 1.1. 安装Node.js 首先，下载好所需的安装包后，先安装Node.js，安装完成后需要注意： 1、设置Node.js全局模块安装路径：这一步的作用在于设置npm全局模块安装的路径，这样以后项目中这些全局模块就可以不用反复安装了，设置方法如下，在cmd命令中输入如下命令：12npm config set prefix &quot;F:\\nodejs\\node_modules\\&quot; // 这里设置模块路径，改成自己的路径npm config set prefix &quot;F:\\nodejs\\node_cache\\&quot; // 这里设置缓存文件的路径 更改完后输入“npm config list”查看命令是否生效，如下： 2、设置Node.js的环境变量；设置Node.js全局模块加载的环境变量NODE_PATH：F:\\webfrontend\\nodejs\\node_modules，该路径为上一步设置的全局安装路径 由于新版的Node.js安装完成后，已经自带NPM功能，所以，NPM不需要单独安装，在系统命令行工具中输入npm -v可以查看npm的当前版本来判断是否成功安装 1.2. 安装Webpack和vue-cli 前面设置好Node.js模块全局路径后，打开cmd窗口（Win+R，输入cmd），输入“npm install webpack -g”，-g表示安装到全局的目录，这样以后在任何目录下都可以使用webpack命令。然后回车，即开始下载Webpack，下载完成后，输入“webpack -v”，查看安装的webpack的版本，判断是否成功。同样，再安装vue-cli，安装完后用“vue -V”查看当前vue-cli版本判断是否安装成功。 注意： - 1、如果遇到网络问题，出现安装缓慢或出错的情况，可以参考： 解决国内NPM安装依赖速度慢问题，或安装“cnpm”，然后使用cnpm进行安装其他模块； - 2、可以一次安装多个模块，例如：“npm install webpack vue-cli -g”模块之间使用空格隔开。 1.3. 安装VS Code 安装完成后，可以进行一些个性化设置，例如， 更改主题：打开“文件 - &gt;首选项 -＞颜色主题”，然后选择一套自己喜欢的主题 用户设置：快捷键“Ctrl+Shift+P”，然后输入“setting”，选择“首选项-打开用户设置”，然后在，右侧栏中输入相应的配置项，例如“” 12345678910111213141516171819202122232425262728293031323334353637383940414243// Place your settings in this file to overwrite the default settings&#123; // 配置 glob 模式以排除文件和文件夹。 \"files.exclude\": &#123; \"**/.git\": true, \"**/.gitignore\": true, \"**/.gitattributes\": true, \"**/.gitkeep\": true, \"**/.eslintignore\": true, \"**/..eslintrc.js\": true, \"**/.eslintrc.js\": true, \"**/.editorconfig\": true, \"**/.svn\": true, \"**/*.DS_Store\": true, // \"**/.vscode\": true, \"**/node_modules\": true, \"**/bin\": true, \"**/obj\": true, \"**/Properties\": true, \"*.csproj\": true, \"*.sln\": true, \"*.user\": true, \"*.suo\": true, \"LICENSE\": true &#125;, \"files.autoSave\": \"off\", \"window.zoomLevel\": 0, \"workbench.editor.enablePreview\": false, \"workbench.statusBar.visible\": true, // \"files.associations\": &#123;\"*.vue\":\"vue\"&#125;, \"workbench.activityBar.visible\": true, \"workbench.colorTheme\": \"One Dark+ (Sublime)\", \"workbench.iconTheme\": \"vs-seti\", // 控制是否显示 minimap \"editor.minimap.enabled\": true, // Controls if the editor should allow to move selections via drag and drop. \"editor.dragAndDrop\": true, // 按 \"Tab\" 时插入空格。该设置在 `editor.detectIndentation` 启用时根据文件内容进行重写。 \"editor.insertSpaces\": false, \"editor.detectIndentation\": false, \"terminal.integrated.shell.windows\": \"C:\\\\Windows\\\\Sysnative\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe\", \"[csharp]\": &#123;&#125;&#125; 设置快捷键快捷键“Ctrl+Shift+P”，然后输入“setting”，选择“首选项-打开用户设置”，然后在，右侧栏中输入相应的配置项，例如： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 将键绑定放入此文件中以覆盖默认值[ &#123; \"key\": \"ctrl+m o\", \"command\": \"editor.foldAll\", \"when\": \"editorFocus\" &#125;, &#123; \"key\": \"ctrl+m l\", \"command\": \"editor.unfoldAll\", \"when\": \"editorFocus\" &#125;, &#123; \"key\": \"ctrl+e c\", \"command\": \"editor.action.addCommentLine\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+e u\", \"command\": \"editor.action.removeCommentLine\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 0\", \"command\": \"editor.foldAll\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 1\", \"command\": \"editor.foldLevel1\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 2\", \"command\": \"editor.foldLevel2\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 3\", \"command\": \"editor.foldLevel3\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 4\", \"command\": \"editor.foldLevel4\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 5\", \"command\": \"editor.foldLevel5\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 6\", \"command\": \"editor.foldLevel6\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 7\", \"command\": \"editor.foldLevel7\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 8\", \"command\": \"editor.foldLevel8\", \"when\": \"editorTextFocus\" &#125;, &#123; \"key\": \"ctrl+m 9\", \"command\": \"editor.foldLevel9\", \"when\": \"editorTextFocus\" &#125;] 安装插件快捷键“Ctrl+Shift+P”，然后输入“install”，选择“扩展-安装扩展”，搜索要安装的插件，比如，输入“vue”，然后会列出vue相关的插件，点击“安装”进行安装，然后重新加载窗口使扩展生效 1.4. 安装Git由于Git是可选安装的，所以暂时先不叙述！ 1.5. 安装HBuilder 官方提供的安装包下载完成后，直接解压就能用，所以不需要安装，双击“HBuilder.exe”就能打开HBuilder就能打开编辑器，由于只用它来真机调试和发布打包，所以这部分内容后面再介绍。 到目前为止，Node.js开发所需的环境基本已搭建完毕，后面开发过程中需要用到的npm模块包用到的时候再安装，下面开始以移动端MIS为例，创建一个Vue项目。 2. 创建Vue项目打开cmd工具，输入cd命令，进入项目创建的目录，例如：然后，输入“vue init webpack mis-mobile”，表示使用vue-cli命令行工具在当前目录下创建一个基于webpack的项目，这个项目名为“mis-mobile”，然后，进行一系列设置，如下： 2.1. 项目结构完成后，使用打开VS Code，在启动页中“开始”下面点击“打开文件夹”，打开刚才创建的Vue项目所在的目录，项结构如图所示： .vscode ：该文件夹包含一个launch.json文件，用于vs code调试信息的配置 build和config：这两个文件夹包含开发环境运行配置和生产环境下打包发布配置，主要包括webpack配置项的设置和一些参数配置 node_modules：该文件夹存放本项目特有的通过NPM安装的所有模块包 server：服务端代码目录，vue初始化的时候没有这个目录，该目录是后面手动添加的 src：源代码目录，包含静态资源目录（assets）、组件（components）、路由（router）、视图（views），主视图（App.vue）和js入口文件（main.js） static：静态资源目录 .babelrc：babel配置，主要是es6语法转化为es5语法的配置 index.html：主页 package.json：整个项目（模块包）的全局配置文件，主要包含项目名称、版本、作者，项目地址，依赖的模块，执行脚本等配置内容，更多的配置项可参考文档：http://www.mujiang.info/translation/npmjs/files/package.json.html 2.2. 安装项目依赖包 打开VS Code终端窗口（快捷键Ctrl+J，也可以使用cmd窗口，但需要切换到项目根目录下），输入“npm install”，然后回车，即开始安装（下载）项目所依赖的所有模块，如果出现红色字体，说明安装出错，检查具体错误原因，重新下载，如果成功，则会以黄色字体列出本次安装的模块。 说明：该命令会检查项目根目录下的package.json文件，然后安装“dependencies”和“devDependencies”参数指定的所有依赖包，由于是局部安装，所有该安装会把这些所有依赖包下载到项目的“node_modules”目录下，下载完成后，会发现该目录下的模块包非常多 2.3. 项目运行 在VS Code终端窗口，输入“npm run dev”，回车后开始编译，编译完成后将自动打开系统默认浏览器显示主页，如图：注意：首次运行该命令，可能会提示如下错误，其中关键的错误信息已经标出来了，该提示表示webpack运行项目的默认端口8080已经被占用了，解决办法：打开文件“config/index.js”，将dev.port默认的8080端口重新设置为新的端口，例如：6060，然后重新执行命令：“npm run dev”，成功后提示如下：说明：“npm run dev”命令会监听项目文件的变化，所以每次更改代码后，页面无需手动刷新即可立即看见更改的效果 2.4. 断点调试 打开文件“build/webpack.dev.conf.js”，找到配置项“devtool”，将该参数设置为“#source-map”，然后，重新运行项目（需要Ctrl+C先停止运行，如果正在运行的话），然后，打开Chrome浏览器的调试窗口，在指定代码处加上断点即可实现源代码的调试，效果如图 关于devtool的几种模式可以参考：[webpack] devtool配置对比 2.5. 打包发布 这里的打包是指利用Webpack将ES6语法和vue文件编译成浏览器能识别和执行的js语法，并且将css、js和html等内容进行合并和压缩等处理，最终形成正是环境上的发布包。 打开VS Code终端窗口，输入“npm run build”，然后回车，打包成功后的界面和文件如下：","excerpt":"Node.js环境下Vue项目开发 本文主要介绍在Node.js环境下，如何进行Vue项目（移动app）开发，包括开发环境的搭建、新建Vue项目、运行项目、Webpack打包、访问移动设备和真机调试及打包发布为app等内容，尽量在每一步过程中详细、清晰明了，让人可以快速上手。","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://github.com/yssa1258/lycorisra/tags/Vue-js/"},{"name":"node.js","slug":"node-js","permalink":"https://github.com/yssa1258/lycorisra/tags/node-js/"}]},{"title":"移动app开发（未完待续）","date":"2017-10-13T16:00:00.000Z","path":"2017/10/14/app-develop-start/","text":"基于H5+DCloud移动开发环境搭建开发工具 Visual Studio Code：简称VS Code，是微软在Build 2015大会上推出来的免费开源且跨平台的现代轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。由于是微软推出的，所以在界面和使用习惯上延续了Visual Studio的风格，对于熟练使用Visual Studio的开发者可以更容易使用 HBuilder：Hbuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。其本身主体是由Java编写，基于Eclipse，所以顺其自然地兼容Eclipse的插件。快，是HBuilder的最大优势，通过完整的语法提示和代码输入法、代码块等，大幅提升HTML、js、css的开发效率。 最佳实践在实际开发过程中，可以使用VS Code进行代码编写，使用HBuilder进行真机联调和打包发布 React Native开发环境搭建Android开发环境软件安装需要安装Java JDK、Android Studio、Python 2和react-native-cli及yarn工具包 Java JDK：Java开发工具包（Java Development Kit），是一种用于构建在Java平台上发布的应用程序、applet和组件的开发环境，包括Java编译器、JVM、大量的Java工具以及Java基础API里面的Java类库和语言规范 Android Studio：包含用于构建Android应用所需的所有工具，推荐选择包含Android SDK的安装包，否则需要单独安装Android SDK Python 2：目前不支持Python 3版本 react-native-cli及yarn工具包：使用npm进行安装：npm i react-native-cli yarn -g环境变量设置安装完成后手动设置相应的环境变量，如下 用户环境变量PATH末尾追加如下： 1PATH：C:\\Users\\xxx\\AppData\\Local\\Android\\sdk\\tools;C:\\Users\\xxx\\AppData\\Local\\Android\\sdk\\platform-tools 系统环境变量新增ANDROID_HOME： 1ANDROID_HOME：C:\\Users\\xxx\\AppData\\Local\\Android\\sdk 系统环境变量新增CLASSPATH： 1CLASSPATH：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 系统环境变量新增JAVA_HOME： 1JAVA_HOME：D:\\software\\java\\jdk1.8.0_131 用户环境变量PATH末尾追加如下： 1Path：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin 真机调试手机打开开发者调试，并通过数据线连接到电脑（是否需要安装手机助手，例如小米手机助手，还未确认），然后，在项目根目录下打开命令行窗口，运行react-native run-android命令，首次运行该命令耗费的时间比较长，如果一切顺利，在手机上就能看到效果。注意： react-native默认使用8081端口，如果该端口被占用，需要手动更改端口，更改方法：左右摇晃手机，打开Dev Tool界面，找到，手动输入电脑上的IP地址和端口，然后重新加载 react-native start 命令后面跟 “–port 端口号”可以手动更改端口，例如： 1react-native start --port 8083 运行react-native run-android命令前，请先运行adb devices命令确保已经连接手机，并且，确保通过react-native start命令已经开启了服务端 IOS开发环境工具 VMware： unlocker206(密码：dp2g)：vmware12解锁os x系统的工具，注意需要关闭UAC，且unlocker释放路径不要包含任何中文和特殊符号！ Mac OS X 10.11 镜像文件(密码：cq4d) 参考 安装vmware workstation12，然后输入许可证，安装完后，打开Windows任务管理器-》服务，找到与VMware相关的服务，全部停止 解压unlocker206安装包，找到win-install.cmd，以管理员身份运行，这一步很关键注意：如果运行后出现cmd窗口一闪而过的现象，说明可能没有执行成功，解决办法：用记事本打开“win-install.cmd”文件，找到以下代码，并删除1234if %errorlevel% neq 0 ( echo Administrator privileges required! exit) 保存后，相关服务重新停止，然后重新管理员运行该批处理命令 打开运行vmware workstation12，选择创建新的虚拟机 参考 vmware12用 unlocker206能不能解锁 OS X系统 Windows下 VM12虚拟机安装OS X 10.11(详细教程) VMware 12安装Mac OS X 10.11 在VMware上装完苹果系统后不能全屏怎么办 VMware 12安装虚拟机Mac OS X 10.10不能上网问题 Node.js环境下Vue项目开发 本文主要介绍在Node.js环境下，如何进行Vue项目（移动app）开发，包括开发环境的搭建、新建Vue项目、运行项目、Webpack打包、访问移动设备和真机调试及打包发布为app等内容，尽量在每一步过程中详细、清晰明了，让人可以快速上手。 开发环境搭建 相较于传统的Web开发，Node.js环境下开发方式最大的区别在于运行环境、模块加载和开发工具等方面，所以，首先熟悉下基于Node.js开发所需的开发环境，包括JavaScript运行环境、打包工具和IDE等，以Windows系统为例，下面是Node.js开发所需的工具： Node.js：Node.js诞生与2009年3月，官网介绍如下： Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 NPM：NPM的全称是Node Package Manager，是一个NodeJS包管理和分发工具。在Node.js实际开发过程中，会使用到大量的模块，使用NPM可以帮助我们安装和管理这些模块包。 Webpack：Webpack是一个模块加载器兼打包工具，它能把各种资源，JS（含JSX）、CSS（含less/sass）、图片和文本等作为模块来使用和处理。文档地址：http://webpack.github.io/docs/ VS Code：全称Visual Studio Code，是微软在Build 2015大会上推出来的开源且跨平台的现代轻量级代码编辑器，是一款主要用于进行前端开发的IDE，支持几乎所有主流的开发语言的语法高亮、代码智能提示、Git、终端和代码调试及VS常用特性。由于是微软推出的，所以在界面和使用习惯上延续了Visual Studio的风格，对于熟练使用Visual Studio的开发者可以更容易使用。其他比较主流的类似IDE还有Sublime Text和Atom，点击相应链接可以详细了解。 HBuilder：Hbuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。其本身主体是由Java编写，基于Eclipse，所以兼容Eclipse的插件。这里我们主要使用它来进行app的调试和发布打包。 vue-cli：基于Vue.js的命令行工具，官方发布 vue.js 项目脚手架，使用 它可以快速创建、运行和发布Vue项目。 Git：是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理 安装Node.js 首先，下载好所需的安装包后，先安装Node.js，安装完成后需要注意1、设置Node.js的环境变量；2、设置Node.js全局模块安装路径。由于新版的Node.js安装完成后，已经自带NPM功能，所以，NPM不需要重新安装，在系统命令行工具中输入npm -v可以查看npm的当前版本来判断是否成功安装 安装Webpack","excerpt":"基于H5+DCloud移动开发环境搭建开发工具 Visual Studio Code：简称VS Code，是微软在Build 2015大会上推出来的免费开源且跨平台的现代轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。由于是微软推出的，所以在界面和使用习惯上延续了Visual Studio的风格，对于熟练使用Visual Studio的开发者可以更容易使用 HBuilder：Hbuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。其本身主体是由Java编写，基于Eclipse，所以顺其自然地兼容Eclipse的插件。快，是HBuilder的最大优势，通过完整的语法提示和代码输入法、代码块等，大幅提升HTML、js、css的开发效率。","tags":[{"name":"app develop","slug":"app-develop","permalink":"https://github.com/yssa1258/lycorisra/tags/app-develop/"}]},{"title":"web前端三种模块规范（CommonJS、AMD和CMD）浅析","date":"2017-10-11T15:11:45.403Z","path":"2017/10/11/webfrontend-modules/","text":"在web开发中，代码模块化有助于降低耦合，最大化实现代码重用，以最少的模块或零部件更快速地满足更多的个性化需求。不同于类似Java和C#等后端语言，前端javascript没有Class和Module等概念（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要很长时间才能投入实用），所以在模块化编程这块，javascript天然劣势。不过，在javascript社区的努力下，目前已经有了模块化变成思想，并且已经形成相应的规范，遵循这些模块规范的实现已经成熟并被广泛运用。目前前端有三种模块规范，分别是CommonJS、AMD和CMD。 CommonJS：CommonJS规范由该组织制定，用在服务端，AMD和CMD用在浏览器环境。根据规范，一个单独的文件就是一个模块，加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。最典型的例子就是node.js的模块系统，就是参照CommonJS规范实现的，在CommonJS中，有一个全局的方法require，用于加载模块。 AMD)：“Asynchronous Module Definition”的缩写，即异步模块定义。由于CommonJS实现的模块是在服务器端运行，并且所有模块都存放在本地硬盘中，而且是同步加载，模块加载效率主要取决于硬盘读取效率。所以，CommonJS模块不适用与浏览器环境，因为浏览器环境，模块都是存放在服务器，客户端加载模块的效率取决于网络的快慢，并且加载方式是异步请求，所以需要维护好模块的加载顺序，同时防止由于加载时间漫长导致的浏览器“假死”。在此种背景下，就诞生了AMD规范，典型的实现是RequireJS，其特点是提前执行（异步加载：依赖先执行+延迟执行 CMD：“Common Module Definition”的缩写，即通用模块定义，CMD规范是国内发展而来，其著名实现有Sea.js，Sea.js特点：延迟执行（运行到需加载，根据顺序执行） CommonJSCommonJS是服务器端模块的规范，由Node推广使用，根据CommonJS规范： 一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 输出模块变量的最好方法是使用module.exports对象。 加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象所以，CommonJS归法实现示例可以如下，：123456789101112131415161718math.jsexports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum;&#125;;increment.jsvar add = require('math').add;exports.increment = function(val) &#123; return add(val, 1);&#125;;index.jsvar increment = require('increment').increment;var a = increment(1); //2 AMDAMD规范采用异步方式加载模块，模块的加载不影响它后面的语句的执行，所有依赖这个模块的语句都定义在回调函数中，等加载完成后，这个回调函数开始执行。AMDye是采用require语句加载模块，但不同的是，它要求两个参数：1require([module], callback); 第一个参数module是一个数组，里面的成员是要加载的模块；第二个参数callback则是模块加载成功后要执行的回调函数。将上面的代码改成AMD型时如下：123require(['math'], function(math) &#123; math.add(2, 3);&#125;) math.add与math模块加载不是同步的，所以浏览器不会发生“假死”，因此，AMD规范更适用于浏览器环境遵循AMD规范的实现有RequireJS，实际上AMD就是在RequireJS在推广过程中对模块定义的规范化产出，它主要解决如下两个问题： 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器中 js加载的时候浏览器会停止页面的渲染，加载文件越多，页面失去响应的时间就越长RequireJS定义了一个全局函数define，用来模块的定义：1define(id?, dependencies?, factory); define函数参数说明如下： id：指定模块的名称，可选；如果没有提供该参数，则模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字） dependencies：是一个当前模块依赖的已被模块定义的模块标识的数组字面量,依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法 factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值以下是RequireJS的模块定义和加载示例：12345678910111213math.jsdefine('math',['jquery'], function ($) &#123; return &#123; add: function(x, y) &#123; return x + y; &#125; &#125;;&#125;);// 模块加载require(['jquery', 'math'], function ($, math) &#123; console.log(math.add(10, 100));//110&#125;); CMDCMD与AMD有共同之处，主要不同的地方在于模块的定义和加载（运行和解析）时机有所不同，在CMD规范中，一个文件就是一个模块，代码格式如下：123define(function(require, export, module) &#123; // 代码&#125;) 第一个参数require是用于把其他模块导入进来，exports用于导出当前模块的属性和方法，module是一个对象，用于存储当前模块相关联的属性和方法 AMD与CMD的区别AMD时依赖关系前置，在定义模块的时候就要声明其依赖的模块，而CMD时按需加载，依赖就近，只有在用到某个模块 的时候再加载，两者代码风格对比如下：12345678910111213// AMD默认推荐写法，依赖必须在最开始就写好define(['./a', './b'], function(a, b) &#123; a.doSomething(); b.doSomething();&#125;)// CMDdefine(function(require, exports, module) &#123; var a = require('./a'); // 依赖就近书写 a.doSomething(); var b = require('./b'); // 依赖就近书写 b.doSomething();&#125;) CMD规范的实现有seajs，以下是seajs使用示例：123456789101112// 定义模块myModeul.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active'); exports.data = 1;&#125;)// 加载模块seajs.use(['myModule.js'], function(my)&#123; var star = my.data; console.log(star); //1&#125;); 结束语 历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，这对开发大型的、复杂的项目形成了巨大障碍。在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西,比如，CommonJS模块就是对象，输入时必须查找对象属性。 参考 ECMAScript 6 入门 Javascript模块化编程 前端模块化（CommonJs,AMD和CMD） js模块化历程","excerpt":"在web开发中，代码模块化有助于降低耦合，最大化实现代码重用，以最少的模块或零部件更快速地满足更多的个性化需求。不同于类似Java和C#等后端语言，前端javascript没有Class和Module等概念（正在制定中的ECMAScript标准第六版，将正式支持”类”和”模块”，但还需要很长时间才能投入实用），所以在模块化编程这块，javascript天然劣势。不过，在javascript社区的努力下，目前已经有了模块化变成思想，并且已经形成相应的规范，遵循这些模块规范的实现已经成熟并被广泛运用。目前前端有三种模块规范，分别是CommonJS、AMD和CMD。","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/yssa1258/lycorisra/tags/webpack/"},{"name":"docs","slug":"docs","permalink":"https://github.com/yssa1258/lycorisra/tags/docs/"}]},{"title":"webpack中文文档（v3.5.5）","date":"2017-10-11T14:44:47.373Z","path":"2017/10/11/hello-webpack/","text":"webpack中文文档（v3.5.5）webpack-chinawebpack 源码解析","excerpt":"","tags":[{"name":"webpack","slug":"webpack","permalink":"https://github.com/yssa1258/lycorisra/tags/webpack/"},{"name":"docs","slug":"docs","permalink":"https://github.com/yssa1258/lycorisra/tags/docs/"}]},{"title":"npm的package.json中文文档","date":"2017-10-09T16:00:00.000Z","path":"2017/10/10/package.json/","text":"npm的package.json中文文档官方文档","excerpt":"","tags":[{"name":"npm","slug":"npm","permalink":"https://github.com/yssa1258/lycorisra/tags/npm/"},{"name":"package","slug":"package","permalink":"https://github.com/yssa1258/lycorisra/tags/package/"}]},{"title":"前端书签","date":"2017-09-24T00:59:38.341Z","path":"2017/09/24/bookmarks/","text":"RequireJS实例分析 快速理解RequireJs张鑫旭杜瑶汤姆大叔腾讯ISUX – 社交用户体验设计携程设计委员会百度fex %SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0\\;F:\\nodejs\\;F:\\nodejs\\node_modules\\;D:\\software\\TortoiseGit\\bin;D:\\software\\Git\\cmdW3cpluswhycssjQuery之家前端网前端开发Less 中文网RequireJS 中文网gulp中文网LESSCSS中文网禅意花园再谈 CSS 预处理器 资源类做好网站伯乐在线前端里WEB骇客iconmoon 手册JSDoc 介绍CSS参考手册jQuery APIjQuery API 1.12中文文档JavaScript 标准参考教程轻量级Web应用开发编码规范 工具类在线工具SVG 贝塞尔曲线控制在线转换工具图片转Base64在线图片去底工具LOGO在线制作 收藏编写更好的CSS代码CSS之旅（1）：为什么要用CSS必须记住的 30 类 CSS 选择器时尚且健壮: 实现更优秀的CSSCSS实现垂直居中的5种方法CSS十问——好奇心+刨根问底=CSSerMarkdown 编辑器语法指南深入理解学习Git工作流CSS之LESScss3选择器（一）GitHub 上一份很受欢迎的前端代码优化指南-强烈推荐收藏css知多少前端文摘：深入解析浏览器的幕后工作原理纯JS实现旋转木马图片展示效果前端必读：浏览器内部工作原理为什么说DOM操作很慢自定义浏览器滚动条的样式，打造属于你的滚动条风格jQuery带日期的指针时针使用脚本动态操作 SVG 文档我所了解的javaScript细节 - 静逸 - 博客园深入理解jQuery插件开发解密jQuery事件核心 - 绑定设计（一）【深入浅出jQuery】源码浅析–整体架构jQuery选择器总结浅谈JSON 数据源格式 - 钢钢 - 博客园js闭包（变量引用函数内部函数） - yuzhongwusan - 博客园javascript客户端检测技术 - 龙恩0707 - 博客园锤子科技的前端源码——体验静态资源优化 - Mafly - 博客园逐渐深入地理解Ajax - WEB前端 - 伯乐在线常用的Javascript设计模式 - WEB前端 - 伯乐在线Angularjs,WebAPI 搭建一个简易权限管理系统LearnAngular：在线学习 AngularJS 的免费交互教程CodingLabs - 使用SeaJS实现模块化JavaScript开发HTML+CSS3 纯代码实现转盘效果","excerpt":"RequireJS实例分析 快速理解RequireJs张鑫旭杜瑶汤姆大叔腾讯ISUX – 社交用户体验设计携程设计委员会百度fex","tags":[]},{"title":"mysql环境搭建","date":"2017-09-24T00:59:37.966Z","path":"2017/09/24/mysql-start/","text":"1、下载mysql，下载地址 2、解压下载好的压缩包到目录：D:\\software\\mysql-5.6.17-winx64；3、设置系统环境变量，具体如下：计算机 -》 属性 -》 高级系统设置 -》 环境变量 -》 环境变量 -》系统变量，双击“Path”行，弹出“编辑系统变量”对话框，变量值后面追加“D:\\software\\mysql-5.6.17-winx64\\bin”； 4、修改my-default.ini文件：123basedir = D:\\software\\mysql-5.6.17-winx64datadir = D:\\software\\mysql-5.6.17-winx64\\dataport = 3306 5、安装mysql服务，打开cmd命令，在bin目录下运行如下命令：12D:\\software\\mysql-5.6.17-winx64\\bin&gt;mysqld -installService successfully installed. 这样执行成功后，输入services.msc，可以看到服务列表中已经新增了mysql服务。6、启动mysql服务，命令如下：1D:\\software\\mysql-5.6.17-winx64\\bin&gt;net start mysql 如果服务启动成功，则输入mysql即可连接到mysql。 设置mysql可以远程连接mysql默认root用户没有密码，输入mysql -u root 进入mysql1、初始化（修改）root密码，进入mysql数据库，修改密码：12use mysql;update user set password = password(&apos;123&apos;) where user = &apos;root&apos;; 2、允许mysql远程访问，可以使用下面三种方式：a) 修改user表1234mysql -u root -puse mysql;update user set host = &apos;%&apos; where user = &apos;root&apos;;select host,user from user; b) 授权，例如项root使用123从任何主机上连接到mysql服务器1grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;123&apos; with grant option; c) 在安装mysql的机器上运行123mysql -h localhost -u root // 进入mysql服务器grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; with grant option;flush privileges; //使修改有效","excerpt":"1、下载mysql，下载地址 2、解压下载好的压缩包到目录：D:\\software\\mysql-5.6.17-winx64；3、设置系统环境变量，具体如下：计算机 -》 属性 -》 高级系统设置 -》 环境变量 -》 环境变量 -》系统变量，双击“Path”行，弹出“编辑系统变量”对话框，变量值后面追加“D:\\software\\mysql-5.6.17-winx64\\bin”；","tags":[{"name":"mysql","slug":"mysql","permalink":"https://github.com/yssa1258/lycorisra/tags/mysql/"},{"name":"database","slug":"database","permalink":"https://github.com/yssa1258/lycorisra/tags/database/"}]},{"title":"欢迎使用 Cmd Markdown 编辑阅读器","date":"2017-09-24T00:59:37.825Z","path":"2017/09/24/cmdMarkdown/","text":"我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） 除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载： Windows/Mac/Linux 全平台客户端 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。 什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以 1. 制作一份待办事宜 Todo 列表 [ ] 支持以 PDF 格式导出文稿 [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 [x] 新增 Todo 列表功能 [x] 修复 LaTex 公式渲染问题 [x] 新增 LaTex 公式编号功能 2. 书写一个质能守恒公式[^LaTeX]$$E=mc^2$$ 3. 高亮一段代码[^code]1234567@requires_authorizationclass SomeClass: passif __name__ == '__main__': # A comment print 'hello world' 4. 高效绘制 流程图12345678st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 5. 高效绘制 序列图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 6. 绘制表格 项目 价格 数量 计算机 \\$1600 5 手机 \\$12 12 管线 \\$1 234 7. 更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。 总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。 什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。 1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！ 2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。 3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右测的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！ 4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。 5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。 6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏： 通过管理工具栏可以： 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式 7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。 工具栏上的五个图标依次为： 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境 8. 阅读模式在 阅读工具栏 点击 或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。 9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档： 标签： 未分类 标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示： 10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 (Ctrl+Alt+P) 发布这份文档给好友吧！ 再一次感谢您花费时间阅读这份欢迎稿，点击 (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！ 作者 @ghosert2015 年 06月 15日 [^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。 [^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。","excerpt":"我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown： 整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持）","tags":[]},{"title":"零基础之一步步搭建hexo博客","date":"2016-05-10T02:23:00.000Z","path":"2016/05/10/hello-hexo/","text":"hexo是什么Hexo 是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen特点：不可思议的快速 ─ 只要一眨眼静态文件即生成完成支持 Markdown仅需一道指令即可部署到 GitHub Pages 和 Heroku已移植 Octopress 插件高扩展性、自订性兼容于 Windows, Mac &amp; Linux官网地址：hexo 准备1、Markdown：是一种轻量级的【标记语言】，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。Markdown语法Markdown——入门指南2、nodejs：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。nodejs中文网 开始1、安装hexo123F:cd F:F:\\webfrontend\\toolsnpm install hexo --save 2、初始化一个blog1F:\\webfrontend\\tools\\hexo&gt;hexo myblog 3、启动服务器123F:\\webfrontend\\tools\\hexo\\myblog&gt;hexo serverINFO Start processingINFO Hexo is running at http://localhost:4000/.Press Ctrl+C to stop. 新建文章当要新增一篇文章时，可以在myblog根目录下通过hexo new title命令来实现1hexo new hello 命令执行完后，hexo会在source/_posts/下新建一个hello.md文件，文章基本配置如下：12345678910title: 文章标题date: 文章发布日期tags: - 标签1- 标签2...categories:- 目录---这里是正文内容 博客发布，即静态化处理静态化处理就是将博客发布成可以部署到服务器上的各种html页面（包括各种css和js等资源）。hexo提供了hexo g方法，进入myblog根目录，执行1hexo g 执行完后，会发现myblog目录下会生成public文件夹，里面存放的就是刚才生成的静态文件，关于hexo的详细使用说明可以参考官方文档将blog部署到githubhexo已经将发布集成到github的配置，要部署到github只需修改myblog目录下的_config.yml文件，打开_config.yml文件，进行如下配置：123deploy: type: github repo: https://github.com/yourname/blog.git 保存修改后，回到myblog根目录，执行【hexo deploy】,然后，你就会发现public目录下的页面已经发布到github下的gh-pages分支下了。注意：配置文件要严格注意格式，冒号后面需要空格。如果执行命令后没反应或github发布没成功，可能需要先安装hexo-deployer-git，命令如下：123F:cd F:\\webfrontend\\tools\\node_modules\\hexo\\lycorisranpm install hexo-deployer-git --save 注意，需要把hexo-deployer-git安装到myblog目录下的node_modules子目录下，如果安装到hexo目录的子目录node_modules下会无效。安装完之后，再执行【hexo deploy】命令。hexo主题关于hexo的主题，网上已经有非常多的分享了，例如：有哪些好看的 Hexo 主题？上面列出了许多可用的hexo主题，个人而言更倾向于maupassant-hexo主题，其github地址。该主题的应用也比较简单，命令如下：123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-jade --save$ npm install hexo-renderer-sass --save 前面两条命令一般执行没问题，但第三条命令由于国内网络被墙的原因无法正确安装，解决办法是，使用代理或切换到淘宝NPM镜像服务器下安装，可以参考使用hexo时遇到的小坑首先需要安装cnpm，然后通过cnpm安装hexo-renderer-sass12npm install -g cnpm --registry=https://registry.npm.taobao.org$ cnpm install hexo-renderer-sass --save 这样hexo-renderer-sass –save安装好之后，返回到myblog根目录，打开_config.yml配置文件，找到theme: 改为maupassant，保存并再次运行hexo server，在浏览器中浏览，这时会发现maupassant已经应用成功，但是，博客样式却乱了，解决办法是，从在线demo中下载样式文件，放到myblog\\themes\\maupassant\\source\\css目录下，然后，修改文件myblog\\themes\\maupassant\\layout\\base.jade，找到相应的style.css引用如下：1link(rel=&apos;stylesheet&apos;, type=&apos;text/css&apos;, href=url_for(theme.css)+&apos;/style.css?v=&apos; + theme.version) 保存，重新刷新网页，此时会看到maupassant主题可以正常显示了~hexo语法简写1234hexo g = hexo generatehexo d = hexo deployhexo s = hexo serverhexo n = hexo new hexo中文文档Hexo在github上构建免费的Web应用Hexo搭建Github静态博客读立写生","excerpt":"hexo是什么Hexo 是一个基于nodejs 的静态博客网站生成器，作者是来自台湾的 Tommy Chen特点：不可思议的快速 ─ 只要一眨眼静态文件即生成完成支持 Markdown仅需一道指令即可部署到 GitHub Pages 和 Heroku已移植 Octopress 插件高扩展性、自订性兼容于 Windows, Mac &amp; Linux官网地址：hexo","tags":[{"name":"hexo","slug":"hexo","permalink":"https://github.com/yssa1258/lycorisra/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://github.com/yssa1258/lycorisra/tags/github/"},{"name":"blog","slug":"blog","permalink":"https://github.com/yssa1258/lycorisra/tags/blog/"},{"name":"入门","slug":"入门","permalink":"https://github.com/yssa1258/lycorisra/tags/入门/"}]},{"title":"Markdown快速入门","date":"2016-05-03T11:13:47.000Z","path":"2016/05/03/hello-markdown/","text":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客 1、段落一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。 2、标题Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。例如： 一级标题二级标题三级标题四级标题五级标题六级标题 3、区块区块引用则使用 email 形式的 ‘&gt;’ 角括号。 这是一段引用的文字这是一段引用的文字这是一段引用的文字这是一段引用的文字这是一段引用的文字这是一段引用的文字这是一段引用的文字这是一段引用的文字 4、修辞和强调Markdown 使用星号和底线来标记需要强调的区段。例如：这是一段强调文字（使用星号）这是一段强调文字（使用底线） 5、列表无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的使用星号： Candy. Gum. Booze.加号： Candy. Gum. Booze.和减号 Candy. Gum. Booze. 有序的列表则是使用一般的数字接着一个英文句点作为项目标记： Red Green Blue 6、链接Markdown 支援两种形式的链接语法： 【行内】和【参考】两种形式，两种都是使用角括号来把文字转成连结。 行内形式是直接在后面用括号直接接上链接：例如：百度，你也可以选择性的加上 title 属性：例如： 1[百度](https://www.baidu.com/ \"百度一下，你就知道\") 参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容： 1234I get 10 times more traffic from [谷歌][1] than from[雅虎][2] or [MSN][3].[1]: http://google.com/ \"Google\"[2]: http://search.yahoo.com/ \"Yahoo Search\"[3]: http://search.msn.com/ \"MSN Search\" I get 10 times more traffic from 谷歌 than from雅虎 or MSN. 7、图片图片的语法和链接很像，也是分为行内和参考两种形式 行内形式（title 是选择性的）： 1![alt text](/path/to/img.jpg \"Title\") 参考形式： 12![alt text][id][id]: /path/to/img.jpg \"Title\" 上面两种方法都会输出 HTML 为：1&lt;img src=\"/path/to/img.jpg\" alt=\"alt text\" title=\"Title\" /&gt; 8、代码在一般的段落文字中，你可以使用反引号 ` 来标记代码区段，区段内的 &amp;、&lt; 和 &gt; 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 &amp;、&lt; 和 &gt; 也一样会自动转成 HTML 实体。123456789document.getElementById('AwardComment').onkeyup = function () &#123; var self = this; setTimeout(function () &#123; var val = self.value, curLength = val.length, maxLength = self.maxLength; document.getElementById('tips').innerHTML = '还可以输入' + (maxLength - curLength) + '个字'; &#125;)&#125;; 参考链接 Markdown语法说明文档 markdown编辑器 认识与入门 Markdown","excerpt":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客","tags":[{"name":"入门","slug":"入门","permalink":"https://github.com/yssa1258/lycorisra/tags/入门/"},{"name":"Markdown","slug":"Markdown","permalink":"https://github.com/yssa1258/lycorisra/tags/Markdown/"}]}]